-- Nate Sands
-- 10 March 2020
-- CSc510003
-- Prof. Troeger
-- CCNY

-- PROBLEM SET 4 --

{- * Instructions
  In all of these exercises, which draw on Chapters 1 - 6, pay attention to the type signatures!

* Problem 1
  You wrote a function (let's now call it subst) for Problem 7 of Problem Set 3:  the call
      subst old new lst
  replaced every occurrence of old in lst by new.  I would like you now to write two more
  versions of subst -- one using foldl and the other using foldr.
-}

-- the disadvantage of this function is that it uses costly (++)

substFL :: (Eq a) => a -> a -> [a] -> [a]
substFL old new = foldl (\acc x -> if x == old
                          then (acc ++ [new])
                          else (acc ++ [x])) []

-- so we could write:

substFL' :: (Eq a) => a -> a -> [a] -> [a]
substFL' old new xs  = reverse ( foldl (\acc x -> if x == old
                                         then new : acc
                                         else x : acc) [] xs)
-- but it makes more sense to write

substFR :: (Eq a) => a -> a -> [a] -> [a]
substFR old new = foldr (\x acc -> if x == old
                          then new : acc
                          else x : acc) []
  

{-
* Problem 2
  Solve Exercise 1.32 (a) in Abelson and Sussman -- using Haskell, of course.  I am content with
  just a recursive solution, but then ask that you implement it twice: once without foldr and once
  using foldr.  After all, they do call the function 'accumulate'.
-}

{-
We want to create an abstract procedure to perform arbitrary operations
on an arbitrary sequence of numbers... for instance, to calculate the product of cubes
between a and b.
-}

-- recursive version:
accumulate :: (Num a, Ord a) => (a -> a -> a) -> a -> (a -> a) -> a -> ( a -> a) -> a -> a
accumulate combiner nullValue term a next b
  | a > b = nullValue
  | otherwise =  combiner (term a) (accumulate combiner nullValue term (next a) next b)

-- e.g. Find the product of cubes between a and b

prodOfCubes a b = accumulate (*) 1 (^3) a ((\a -> a+1)) b

-- e.g. Find sum of sequence 1/(1*3) + 1/(5*7) + 1/(9*11) + ....

piTerm a = 1.0 / (a * (a+2))
piNext a = a + 4
piSum a b = accumulate (+) 0 piTerm a piNext b

-- Now we want to write a similar function using a right fold.
-- Say we wanted to calculate the product of odd cubes from one
-- up to and including the cube of of some integer b.  We
-- could write:

term x = x + 2 
terms = 1 : [ term x |x <-terms] -- generates odd numbers
prodOddCubes b = foldr (*) 1 (map (^3) (takeWhile (<=b) terms))

-- Or, to calculate sum of sequence 1/(1*3) + 1/(5*7) + 1/(9*11) + ....
piTermNext x = x +4
piSeqFR = 1 : [ piTermNext x | x <- piSeqFR ]
piSumFR b = foldr (+) 0 (map (\x -> 1.0 / (x*(x+2))) (takeWhile (<=b) piSeqFR))

-- These suggest the following form:
accumulateFR :: (Num a, Ord a) => (a -> a -> a) -> a -> (a -> a) -> a -> (a -> a) -> a -> a
accumulateFR combiner nullValue term a next b =
  foldr combiner nullValue (map term (takeWhile (<=b) seqn))
  where seqn = a : [ next x | x  <- seqn ]

-- e.g. compute the geometric series 1 + x + x^2 + ... + x^n = x^(n+1) - 1

geoSeries x n = accumulateFR (+) 0 ((\a -> x^a)) 0 ((\a -> a + 1)) n

-- Suppose we want to compute the series the Liebniz formula for pi/4 =  1 - 1/3 + 1/5 - 1/7 ...
-- We need to a way to account for alternating sign...
-- Note floor(1/2) = 0, floor(3/2) = 1, floor(5/2) = 2, floor(7/2) = 3, floor(9/2) = 4..
-- So (-1)^[floor a/ 2] gives sign of the term generated by a.

liebnizTerm x = (-1)^(floor (x/2)) * (1.0 / x)
liebnizNext x = x + 2
piOver4 n = accumulateFR (+) 0 liebnizTerm 1 liebnizNext n
-- 4 * piOver4 100000 returns 3.1415726535897956

{-
* Problem 3
  Solve Exercise 1.37 in Abelson and Sussman, using Haskell.  Give both recursive and iterative 
  solutions.  Use local functions in each.  Give proofs.
-}

{- Define a function to compute a (finite) continued fraction -}

-- recursive version:

contf :: (Num a, Eq a, Fractional b) => (a -> b) -> (a -> b) -> a -> a -> b
contf n d i k
  | i == k = (n k) / (d k)
  | otherwise = (n i) / ((d i) + (contf n d (i+1) k))
contFrac n d k = contf n d 1 k

-- Proof:
-- We claim that the procedure (contf n d i k)
-- returns the value of the continued fraction
-- whose (uppermost) numerator is (n i), and whose ultimate
-- denominator is (d k).

-- Base case:
-- When i = k, the procedure returns
-- (n k) / (d k).

-- IH: 
-- Assume (contf n d i k) returns the value of the
-- continued fraction whose numerator is (n i) and
-- whose final denominator is (d k).  
--
-- The value of the continued fraction whose numerator
-- it (n i-1) is 
--          (n i-1) / ((d i-1) + (contf n d i k))
-- which is the value returned by (contf n d i-1 k).

-- Golden Ratio:
-- Here we use (contFrac one one k) to approximate 1 / phi, then determine
-- the value of k needed in order to get an approximation that is
-- accurate to within 4 decimal places
one :: (Num a, Fractional b) => a -> b
one i = 1.0

phi = 1.6180339887
goldenRatio :: (Num a, Eq a, Fractional b) => a -> b
goldenRatio k = (1 / (contFrac one one k))
-- The following procedure iterates through values of
-- k until the the function goldenRatio yields the
-- required accuracy
grK k
  | abs (phi - (goldenRatio k)) < (0.00001) = k
  | otherwise = grK (k + 1)

-- Answer: 13

-- Iterative continued fraction  procedure:

contFracIter :: (Num a, Eq a, Fractional b) => (a -> b) -> (a -> b) -> a -> b -> b
contFracIter n d i result
  | i == 1 = result
  | otherwise = contFracIter n d (i-1) ((n (i-1))/ ( (d (i-1)) + result))

contFracI :: (Num a, Eq a, Fractional b) => (a -> b) -> (a -> b) -> a -> b
contFracI n d k = contFracIter n d k ((n k) / (d k))
-- Proof:
-- Invariant:  the variable result contains the value of the continued
-- fraction whose numerator is (n i) and whose final denominator
-- is k.
--
-- Initialization: When the function (contFracI n d k) is called, i=k, and result =
-- (n k) / (d k).

-- Maintenance: when i is decremented, the value of result is updated using
-- the values of (n (i-1)) and (d (i-1)) to maintain the invariant.

-- Termination:  the procedure terminates when i = 1.  By the invariant,
-- the value of result is the continued fraction whose numerator is (n 1).

{-
* Problem 4
  Solve Exercise 1.41 in Abelson and Sussman, using Haskell.  Give a complete explanation
  of the computed result. This is a good opportunity to play with $ -- right-associative
  function composition -- as well.
-}

-- double takes a procedure of one argument and applies it twice.

double :: ( a -> a) -> a -> a
double f x = f $ f x



{-
* Problem 5
  Solve Exercise 1.43 in Abelson and Sussman, using Haskell. Give both recursive and iterative
  solutons.  
-}

-- repeated return the nth application of a function f

-- recursive

repeated :: (Num b, Eq b) => (a -> a) -> b -> a -> a
repeated f n x
  | n == 1 = f x
  | otherwise = f $ repeated f (n-1) x

-- iterative

repeatedIter :: (Num b, Eq b) => (a -> a) -> b -> a -> a
repeatedIter f n x
  | n == 1 = f x
  | otherwise = repeatedIter f (n-1) (f x)

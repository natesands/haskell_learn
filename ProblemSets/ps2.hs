-- Nate Sands
-- 19 Feb 2020
-- CSc510003
-- Prof. Troeger
-- CCNY

-- PROBLEM SET 2 --


{-
PROBLEM 1
Using the term 'm-list' to mean a list of length m, write a 
function allMListsV1 so that for integers m > 0 and n > 0, 
allMListsV1 m n returns the list of all m-lists of integers j, 1 <= j <= n
-}

allMlistsV1 :: (Ord a, Enum a, Num a) => a -> a -> [[a]]
allMlistsV1 m n
  | n <= 0  = error "n must be positive integer."
  | m <= 0  = error "m must be positive integer."
  | m == 1  = [ [x] | x <- [1..n] ]
  | otherwise = [ x:xs | x <- [1..n], xs <- allMlistsV1 (m-1) n ]
  
{-
PROBLEM 2
Now generalize your solution to Problem 1 so that the second input is an
arbitrary list, l.  Call this function allMLists.
-}

allMLists :: (Ord a, Num a, Enum b) => a -> [b] -> [[b]]
allMLists _ []  = []
allMLists m xs
  | m <= 0  = []
  | m == 1  = [ [x] | x <- xs ]
  | otherwise = [ x:ys | x <- xs, ys <- allMLists (m-1) xs ]


{-
PROBLEM 3
You know from the Discrete Math course how to compute the
length of the lists resulting from allMlists m [1..n].
Work out some of these numbers, and then test the feasibility
of actually computing these lists.  For which m and n would you say that
the computation is no longer feasible?

The number of m-lists generated by a list of length n is n^m.

-}

{-
PROBLEM 4
Write a function allMListsWithDistinctElements which inputs a positive
integer m and a list l, and which returns all distinct m-lists of
elements of l.
-}

allMListsWithDistinctElements :: (Ord a, Num a,
                                  Eq b, Enum b) => a -> [b] -> [[b]]
allMListsWithDistinctElements _ []  = []
allMListsWithDistinctElements m xs
  | m <= 0  = []
  | m == 1  = [ [x] | x <- xs ]
  | otherwise = [ x:ys | x <- xs,
                         ys <- allMListsWithDistinctElements (m-1) xs,
                         not (elem x ys) ]

{-
PROBLEM 5
With the introduction of types and recursion, we can revisit the
Queens problem.  The goal this time is to find all safe placements of n
queens on an nxn chess board.  

I have found it convenient to use lists instead of tuples -- for example,
a position on the board is [j,k] for  integers j and k, with 1 <= j <= n and
1 <= k <= n.

Throughout, n is the size of (one side of) the square board.

The idea for the recursion is to assume that at stage k, configurations is
the list of all safe placements of k queens in the last k columns of the board.
That is, each element of configurations is a list of k configurations (a list
of board positions) representing positions of k queens who are not attacking
each other.  Each configuration is then (tentatively) extended by a position
of a queen in the (k-1)st column.  This is accomplished using comprehension,
and results in a list of lists of configurations -- if we apply flatten, we
again have a list of configurations.  BUT it is no longer the case that all
of these configurations are safe -- we filter for safety before moving
 on to the next stage, with the invariant (configurations consists of all safe
placements of queens in the last k columns of the board) re-established with
k having increased by 1.

The process completes when k == n.
-}


queens n = configurations n n

configurations :: (Fractional a, Eq a, Enum a) => a -> a-> [[[a]]]
configurations 0 n = [[]]
configurations k n = [ xs:xxs | xs <- kthFilePositions k n,
                              xxs <- configurations (k-1) n,
                              noMatchingRank xs xxs,
                              noDiagonal xs xxs]
                     
kthFilePositions k n = [ [k,x] | x <- [1..n] ]                    
noMatchingRank xs xxs = and [ (xs !! 1) /= (y !! 1) | y <- xxs ]
noDiagonal xs xxs = and [ abs (slope xs y) /= 1 | y <- xxs ]
  where slope p1 p2 = ((p1 !! 1) - (p2 !! 1)) / ((p1 !! 0) - (p2 !! 0))

-- length (queens 8) = 92
